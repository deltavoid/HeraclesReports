

benchmark note

1. introduction
    
    延迟敏感程序在数据中心中十分普遍。
    尾延迟（不是平均延迟）也是描述程序的重要指标，尾延迟希望描述延迟时间的上界，即最大的延迟时间，具体取的是延迟时间序列中第95个百分点打数据。

    tailbench提供了一组测量尾延迟的工具，具有如下特性：
        选择了8个具有代表性打延迟敏感程序;
        将所有工作负载集中在一个统一的总控程序之下（即harness）;
        可以在实际系统和模拟器上运行;

2. background

    延迟敏感程序的剖析

        一台机器的延迟具有一定的分布，衡量标准可以有平均延迟和尾延迟。
        在分布式环境下，尾延迟会具有非常重要的影响，考虑下面的场景：
        通常网页搜索程序具有一个接受请求的主节点和许多处理请求的叶节点，主节点将任务分解发送到叶节点，叶节点处理完后将结果返回主节点，主节点将叶节点的结果汇总成总结果返回用户。此时主节点的延迟取决于所有叶节点中延迟最高的那个，
        如果叶节点平均延迟很低，但尾延迟很高，那么在大量叶节点中，就会出现少量的延迟很高的机器，由于主节点打延迟取决于最高的叶节点延迟，因此主节点就经常性的表现出很高的延迟。
        因此即使叶节点平均延迟很低，但尾延迟很高的情况下依然会对服务质量产生巨大打影响，因此尾延迟十分重要。

    tailbench相对于其他程序的优点

        测量更加全面;
        使用更加容易;

3. tailbench applications

    tailbench 总的来说提供了一个框架（harness）和8个测量程序，框架可以跑在3种配置下。下面首先介绍8个程序。

    xapian
        一个搜索引擎
    masstree
        一个内存里的键值对存储

    moses
        一个基于统计的机器翻译程序
    sphinx
        一个精准语音识别程序
    img-dnn
        一个手写识别程序。
    specjbb
        一个工业标准的java中间件测试程序
    silo
        一个内存里的事务数据库
    shore
        一个硬盘里的事务数据库

4. tailbench harness

    harness实际上是tailbench的总控程序,提供上述8个延迟敏感程序的运行环境，提供输入并收集输出。
    harness有3个部分: traffic shaper，request queue，statistics collector。

    traffic shaper 控制请求流的时间特性。
    request queue 收集所有的请求并且测量排队时间。
    statistics collector 聚集时间数据。

    工作流程如fig1左上角的图示。
    application client将请求发送给traffic shaper，
    traffic shaper经过一定的整理后将请求发送给request queue，
    request queue模拟排队时间并将请求发送给application，
    application处理完后将响应返回给stat collector。
    这样一次处理流程完成。

    harness可以工作在3种配置下：网络配置，本地回环配置，集成配置。

    网络配置:
        网络配置模拟数据中心的环境，具有多个节点和将节点连通的网络环境。
        节点分为客户节点和服务节点，通常客户节点具有多个，用于发出请求，服务节点只有一个，运行服务程序（即要测试的延迟敏感程序），节点间通过TCP/IP通信。
        每个客户节点上都有traffic shaper和stat collector，服务节点上有request queue 和 application。
        客户节点将请求发送到traffic shaper， traffic shaper将请求通过TCP/IP发送给服务节点上的任务队列，任务队列再将请求发送给application，application处理完后通过TCP /IP返回给对应节点上的stat collector。这样一次处理流程就完成了。
        客户节点同时存在多个，模拟实际中的任务环境。

    本地回环配置：
        本地回环配置去除了网络配置中的网络环境，所有程序运行在同一个机器上，但保留了TCP /IP，程序通过TCP /IP应用本地回环端口进行通信。
    
    集成配置：
        集成配置去除了本地回环配置中的TCP/IP，所有程序运行在一个进程中，通过共享内存通信。
        
        集成配置不只可以运行在实际机器上，还可以运行在模拟器上。

5. application characterization

    本节测试了各个程序的延迟特性。

    fig2展示了各个程序的服务时间，服务时间指程序处理请求所需要的处理时间。

    fig3展示了响应时间与负载的关系，响应时间指客户端发出请求到收到请求所经历的时间。图中展示了不同负载下的平均延迟，95%位的延迟和99%位的延迟。

    fig4展示了多线程对延迟的影响。


6. validating simplified harness configurations

    本节在实际系统和模拟器上验证了简单配置（即集成配置）。

    A. 介绍了实际系统和模拟器上的配置

    B. 测试了单线程程序

    C. 测试了多线程程序

7. case study

    本节分析了moses和silo在多线程上表现不好的原因。
    主要考虑两个因素:同步开销和共享内存争用（争的应该是带宽）。
    使用了一台理想内存模拟器（内存没有延迟以及内存带宽无限）。

    运行结果显示moses的表现符合理论估计，silo不符合。
    因此结论是moses多线程表现差的原因是内存带宽争用，而silo是线程同步开销。

8. conclusions

    总结了一下tailbench的优点。



